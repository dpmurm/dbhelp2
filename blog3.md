# Урок 3 : Первый раз, первый контроллер..

Первым делом я очень извиняюсь за такой большой перерыв в написании статей в этом разделе. Я наконец то решил проблему по которой не мог писать сообщения в данный раздел, поэтому теперь каждый новый урок будет выходить как минимум раз в неделю...


Хочу вам сразу сказать что мои уроки никак не пересекаются с "Blog Tutorial".
Я использую свои решения (свой подход) и не собираюсь дублировать идеи. Спасибо всем моим читателям которые натолкнули меня пересмотреть вердикт относительна данного раздела.

**Я предполагаю что вы уже знакомы с:**

- Урок2 : Первичная настройка

- Урок1 : Обзор

## Кодим, кодим, перекодим...

Со времён "Урока 2" мои взгляды немного изменились и я решил пересмотреть структуру одной из таблиц. Если вы следовали уроку и создавали все таблицы в базе, выполните следующие действия:

1. воспользуйтесь phpmyadmin что бы открыть вашу базу.

2. найдите и удалите там таблицу category
3. используя SQL выполните следующий код:

```sql
CREATE TABLE `category` (
  `id` int(11) NOT NULL auto_increment,
  `idOwner` int(11) NOT NULL default '0',
  `name` varchar(250) NOT NULL,
  `url` varchar(100) NOT NULL,
  PRIMARY KEY  (`id`)
) ENGINE=InnoDB  DEFAULT CHARSET=utf8 ;
```

Если вы посмотрели код запроса, то наверняка уже поняли что я добавил поддержку вложенности для категорий (возможность рализации простого дерева).

**id** - порядковый номер категории
**idOwner** - номер родительской категории (номер категории в которой находится категория)
**name** - название категории
**url** - префикс URL для категории

Объяснение почему я выбрал данный тип дерева, а не **NestedSets** - выходят за приделы данного урока. В двух словах я хочу сказать что я сторонник простоты и для меня перестраивать ключи всего дерева только что б вставить в него элемент - чуждо (как это происходит с **NestedSets**). Если вы не согласны с моим подходом в данном случае - вы можете использовать любое другое дерево.

Для того чтобы разобраться  как работает дерево - я приведу вам простой пример данных:

| id   | idOwner | name       |
| ---- | ------- | ---------- |
| 1    | 0       | Главный    |
| 2    | 1       | Раздел 1   |
| 3    | 1       | Раздел 2   |
| 4    | 1       | Раздел 3   |
| 5    | 2       | Раздел 1.1 |
| 6    | 3       | Раздел 2.1 |

Пример как это будет выглядеть:

 | Главный
 |--- Раздел 1
 |------- Раздел 1.1
 |--- Раздел 2
 |------- Раздел 2.1
 |--- Раздел 3

Так, думаю с деревом все понятно. Переходим дальше...

## Первый раз, первый контроллер...

Стандартный контроллер для Yii приложения - Site, но если вы внимательно смотрели строчки нашего конфиг файла (protected/config/main.php) вы должны были заметить :

```php
'defaultController'=>'post',
```

данная строка говорит о том что вместо "Site" нашим контроллером по умолчанию будет Post. Также в файле protected/config/main.php удалите строчки которые нам сейчас не нужны:

```php
'sourceLanguage' => 'en',
 'language' => 'ru',
 'theme' => 'classic',
```

Давайте сразу договоримся что файлы блога который мы с вами создаем вы разместили у себя на localhost. Поэтому что бы открыть первую страницу блога - в браузере вы пишите http://localhost/

Рядом с папкой protected создайте папку assets. (она нам понадобиться в будущем)

Если вы сейчас зайдете на свой блог, вы должны увидить ошибку что контроллера Post не найдено или страница не найдена (смотреть).

Войдите в protected/controllers/ и создайте файл PostController.php
```php
<?php

 class PostController extends CController
 {           
     public function actionIndex()
     {
         $this->pageTitle = "Мой блог :: Главная страница";
        
        // создаем простой критерий поиска в котором
        // просто сортируем по колонке created 
        $criteria=new CDbCriteria;
        $criteria->order = 'created DESC';
        
        // Обращаемся к моделе Posts (которую мы создадим немного позже)
        // И передаем нашу критерию, чтобы все сообщения которые
        // мы получим - были отсортированы по дате создания.
        $all_posts = Posts::model()->findAll($criteria);
        
        // Передаем переменную $all_post со всеми постами в отображение index
        // в самом отображении переменная будет доступна по имени $posts
        $this->render('index', array(
            'posts' => $all_posts, 
        ));
    }
}
```

Думаю комментариев будет достаточно что бы понять как это дело работает. Сохраните контроллер и запустите блог. Вы должны увидеть ошибку что Posts.php не найден (смотреть). В принципе это и не удивительно (если вы читали комментарии), нам надо создать модель Posts.

Войдите в protected/models/ и создайте файл Posts.php:
```php
<?php

// Стандартный шаблон для любой модели.
 class Posts extends CActiveRecord
 {        
     public static function model($className=__CLASS__)
     {
         return parent::model($className);
     }
     public function tableName()
     {
         return 'post';   // название нашей таблицы в базе данных
     }
 }
```

Теперь заходите к себе на блог и смотрите что увидим на этот раз :) В идеальном варианте мы должны увидить ошибку (смотреть) что не найдено отображение index.php в которое мы собственно передаем переменную $all_posts. (смотреть)

Если вы видите ошибку связанную с базой данных (смотреть) тогда вы просто забыли в файле config/main.php поменять настройки соединения с базой данных.

Теперь перейдем к созданию простого отображения (index.php) которое выведет на экран нам список всех постов из базы.

Заходим в protected/views/ создаем там папку post,
а теперь в этой папке создаем два файла

index.php:
```php
<table border="0" width="100%" cellpadding="10" cellspacing="10">

 <?php
 if (!empty($posts))
     foreach ($posts as $key => $val) {
         $this->renderPartial('_list',array(
             'post'=>$val,
         )); 
     }
 ?>

 </table>
```
_list.php:
```html
<tr><td>

 <table border="1" width="100%">
     <tr><td><h2>Название : <?=$post->name;?></h2>
     <tr><td><?php echo $post->created;?>
     <tr><td><?php echo mb_substr($post->text, 0, 500), "...";?>
 </table>
```

В файле index.php мы получаем $posts переменную которая содержит в себе все посты из нашей базы (если они есть), а затем в цикле передает информацию по отдельному посту в отображение _list.php где выводятся все данные.

Я мог бы не разбивать вывод на два файла (оставить всё в index.php), но поверьте мне, данное решение намного изящнее и удобнее. (попробуйте приучить себя к такому стилю программирования и поймете что так намного удобнее).

Теперь нам надо добавить данные о постах в базу данных. Используя phpMyAdmin - войдите в базу данных и в таблицу post по добавляйте каких то тестовых данных (2-3 записи). Если нехотите добавлять вручную - загрузите в базу мой небольшой дамп (смотреть);

Теперь если вы откроете свой блог - вы увидите посты которые у вас в базе (смотреть). Если вы видите белый экран - значит добавить посты в базу вас так и не получилось :)

Теперь давайте модифицируем наш контроллер таким образом  что б появилось постраничное листание.
```php
<?php

 class PostController extends CController
 {           
     public function actionIndex()
     {
         $this->pageTitle = "Мой блог :: Главная страница";
         
         $criteria=new CDbCriteria;
         $criteria->order = 'created DESC';
         
         // Создаем обьект класса CPagination в который
         // передаем кол-во наших постов
         $pages=new CPagination(Posts::model()->count($criteria));
         // Сколько сообщений выводить на страницу?
         $pages->pageSize=1;
         $pages->applyLimit($criteria);
         
         $all_posts = Posts::model()->findAll($criteria);
         
         $this->render('index', array(
             'posts' => $all_posts, 
             // теперь нам надо в отображение послать еще
             // и переменную $pages
             'pages' => $pages,
         ));
     }
 }
```

В $pages->pageSize я установил единицу для того чтобы вы (со своими двумя постами в базе) увидели виджет постраничного листания. Вы можете установить любое другое значение для удобства.

Теперь надо добавить виджит постраничного листания в отображение
```php
<?php $this->widget('CLinkPager',array(

         'pages'=>$pages, 
         'maxButtonCount' => 5, // максимальное вол-ко кнопок <- 1..2..3..4..5 ->
         'header' => '<b>Перейти к странице:</b><br><br>', // заголовок над листалкой
 )); ?>
```

(добавьте этот код конец файла view/post/index.php)

Вот в принципе и всё для сегодняшнего урока. Если вы войдете на страницу своего блога - вы увидите одно несчастное сообщение и элемент для листания страниц.

Мне кажется для первого практического занятия по данному уроку - материала я изложил достаточно.

В следующий раз будет два парных урока по темам:

1. Как прикрутить регистрацию (авторизацию) средствами Yii

2. Как создать отдельную страницу для поста


Спасибо всем что читаете мой блог.
Заходите еще!
