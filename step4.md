Шаг 4 : Модель
====
Модель - это класс для работы приложения с базой. Для каждой таблицы с которой предстоит работать — создается своя модель (в Yii это класс наследуемый от CModel или производного от него)...


Вы должны понимать что модель является очень нужной "прокладкой" между вашим приложением и базой данных. Она может включать в себя проверку данных, ассоциации, связи с другими моделями и многое другое.

Наследуя нашу модель от класса [CActiveRecord](http://www.yiiframework.com/doc/api/1.1/CActiveRecord) мы получаем большое кол-во функционала для работы (встроенные функции в виде find, findAll, count и все другие прелести ActiveRecord).

> Хочу сразу заметить что если вы пропустили "Урок 3 : MVC" - вам будет тяжело вникнуть в курс дела.

## Модель в действии

Модели обычно располагаются в папке protected/models и называются аналогично таблице с которой работают. К примеру, модель которая работает с таблицей post может быть названа "Post.php", "Posts.php" и др. Строгого правила как должна называться модель - не существует.

Давайте посмотрим простой пример модели которую я использую в своем блоге. Она имеет стандартный функционал для добавления и обновления записей.
```php
<?php
// Создаем класс Posts и наследуем его от CActiveRecord
class Posts extends CActiveRecord
{        
    // Переопределение данного метода - обязательно для каждой модели
    // не стоит редактировать его если вы не понимаете к чему он
    public static function model($className=__CLASS__)
    {
        return parent::model($className);
    }
    // Указываем имя таблицы с которой работает данная модель
    public function tableName()
    {
        return 'post'; // таблица "posts"
    }
    /**
     * Добавляем новый пост
     *
     */
    public function new_posts() {
        // ...
    }
    /**
     * Обновляем пост в базе
     *
     * @param unknown_type $id
     */
    public function edit_posts($id) {
        // ...
    }
}
```
Первые два метода (tableName, model) являются обязательным для модели. Такие функции как создание, чтение, обновление и удаление (CRUD) — уже встроены в базовый класс модели. Поэтому если вы хотите просто добавить новый пост в базу — совсем не обязательно описывать для этого отдельный метод в модели. (как это сделал я)

Как говорится «не стоит заново изобретать велосипед», поэтому перед тем как что-то добавить в модель — стоит проверить не встроен ли в неё этот функционал разработчиками Yii. К примеру, для добавления/редактирования поста мы можем использовать встроенный метод save():
```php
<?php
// создаем экземпляр класса модели (Posts)
$date = new Posts();            
// поле title заполняем нужным нам значением
// предполагаеться что title это существующее поле в таблице post
$date->title = "Заголовок";
// поле date заполняем текущей датой
// предполагаеться что title это существующее поле в таблице post
$date->date     = date("Y-m-d");
// добавялем в базу. 
$date->save();   // или $date->insert();
```

Согласитесь, всё очень просто. Про все тонкости ActiveRecord вы можете прочитать в отличной статье из оф. документации - [«Actrive Records»](http://www.yiiframework.com/doc/guide/1.1/ru/database.ar). Поэтому я советую познакомиться со всеми встроенными методами модели, прежде чем создавать свои.

## Пример пользовательских методов

Пример модели Posts в которую были добавлены методы скрытия/отображения постов в блоге:
```php
<?php
class Posts extends CActiveRecord
{        
      public static function model($className=__CLASS__)
      {
          return parent::model($className);
      }
      public function tableName()
      {
          return 'post';
      }
      /**
       * Устанавливаем значение поля hidden для 
       * текущего поста - 1. Т.е. скрываем запись.
       */
      public function hide() {
          if (!empty($this->id)) {
              $this->hidden = 1;
              $this->save();
              return true;
          } else {
              return false;
          }
      }
      /**
       * Устанавливаем значение поля hidden для 
       * текущего поста - 0. Т.е. показываем запись.
       */
      public function unhide() {
          if (!empty($this->id)) {
              $this->hidden = 0;
              $this->save();
              return true;
          } else {
              return false;
          }
      }
}
```
Что бы воспользоваться этими методами в контроллере:

```php
// Создаем экземпляр класса модели (Posts)
$my_post = new Posts();
// Заполняем значение поля id что бы знать какую запись мы редактируем
$my_post->id = 55;
// Обращаемся к методу hide
$my_post->hide();
```

## Модель в контроллере

Работать с моделью в контроллере вы можете несколькими способами.

1. Создать экземпляр класса нужной модели и обратиться  к её методами обычным способом:

```php
$Posts = new Posts();
$Posts->my_method();
```



2. Через статический метод model() не создавая перед этим экземпляр модели:

```php
Posts::model()->findAll(...);
```

## Встроенный функционал

Теперь давайте рассмотрим часть популярных методов которые уже встроены в класс CActiveRecord и очень облегчают жизнь. Хочу сразу заметить что здесь описаны не все доступные методы по причине их огромного количества. Полный список доступных функций вы можете прочитать в API на английском языке.

**find**

- condition

- params

Возвращаем первую запись которая соответствует условию \$condition. При этом \$condition может быть представлен как WHERE SQL запрос, либо как критерия поиска (экземпляр класса [CDbCriteria](http://www.yiiframework.com/doc/api/1.1/CDbCriteria)).

Давайте рассмотрим два примера использования $condition.

1. Как SQL
  В качестве \$condition используем where запрос с синонимами вместо значений. В \$params передаем массив вида : синоним = значение.

```php
MyModel::model()->find("id = :id AND login = :login", array(":id" => 5, ":login" => "test"))
```



2. Как Criteria
  В качестве \$condition используем созданный перед этим экземпляр класса CDbCriteria со всеми нужными критериями. Параметр \$params в find использовать не надо (параметры задаются через критерию).

```php
$criteria=new CDbCriteria;
$criteria->condition='id=:id AND login=:login';
$criteria->params=array(':id'=>5, ':login' => 'test');  // задаем параметры
$post=MyModel::model()->find($criteria);
```

**findAll**

- condition

- params

Возвращает все записи которые соответствуют условию $condition.

```php
MyModel::model()->findAll("created = :created", array(":created" => "2008-01-22"))
```

Подробное описание параметров (condition, params) смотри в find()

**findAllByAttributes**

- attributes

- condition
- params

Возвращает все записи которые соответствуют условию в $attributes и $condition. При этом параметр $attributes должен содержать массив вида: «название атрибута» = значение.

```php
#достаем все записи где дата создания (created) равна значению 2008-01-22
MyModel::model()->findByAttributes(array('created' => '2008-01-22'));
```

Подробное описание параметров (condition, params) смотри в find()

**findByAttributes**

- 
  attributes

- condition
- params


Возвращает первую запись которая соответствует условию в $attributes и $condition.
Подробное описание параметров смотри в findAllByAttributes()

**findByPk**

- pk

- condition
- params

Возвращает первую запись  которая отвечает запросу \$condition и первичному ключу \$pk

```php
MyModel::model()->findByPk(1);
```

Подробное описание параметров (condition, params) смотри в find()

**findAllByPk**

- pk

- condition
- params

Возвращает все записи которые отвечают запросу $condition и первичному ключу $pk

Подробное описание параметров (condition, params) смотри в find()

**findBySql**

- sql

- params

Возвращает первую запись которая соответствует $sql.

Подробное описание параметров (params) смотри в find()

**findAllBySql**

- sql

- params

Возвращает все записи которые соответствую $sql.

Подробное описание параметров (params) смотри в find()

**count**

- condition

- params

Возвращает количество записей которые соответствуют $condition.

Подробное описание параметров (params) смотри в find()

**countBySql**

- sql

- params

Возвращает количество записей которые соответствую $sql.

Подробное описание параметров (params) смотри в find()

**exists**

- condition

- params

Проверяем есть ли хоть одна запись которая удовлетворяет условию $condition

Подробное описание параметров (params) смотри в find()

**updateAll**

- attributes

- condition
- params

Обновляет все строчки которые отвечают запросу $condition

Подробное описание параметров (condition, params) смотри в find()

**updateByPk**

- pk

- attributes
- condition
- params

Обновляет все строчки которые отвечают запросу \$condition и первичному ключу \$pk

Подробное описание параметров (condition, params) смотри в find()

**delete**

Удаляем текущую запись с которой работаем.

```php
$model=MyModel::model()->findByPk(666);
$model->delete();
```

**deleteAll**

- condition

- params

Удалит все записи которые соответствую условию $condition.

Подробное описание параметров (condition, params) смотри в find()

**deleteByPk**

- pk

- condition
- params

Удалит все записи которые соответствую условию $condition и первичному ключу $pk.

Подробное описание параметров (condition, params) смотри в find()

**validate**

Проверяет что бы все атрибуты соответствовали правилам указанным в rules().

**beforeSave**

Метод который будет вызван до сохранения текущей записи с которой работаем (экземпляра AR).  Для того чтобы выполнить какие либо действия перед сохранением записи в базу — достаточно просто переопределить данный метод.

**afterSave**

Метод который будет вызван после сохранения текущей записи с которой работаем (экземпляра AR).  Для того чтобы выполнить какие либо действия после сохранения записи в  базу — достаточно просто переопределить данный метод.

**beforeDelete**

Метод который будет вызван до удаления текущей записи с которой работаем (экземпляра AR).  Для того чтобы выполнить какие либо действия до удаления записи из базы — достаточно просто переопределить данный метод.

**afterDelete**

Метод который будет вызван после удаления текущей записи с которой работаем (экземпляра AR).  Для того чтобы выполнить какие либо действия после удаления записи из базы — достаточно просто переопределить данный метод.

**beforeValidate**

Метод который будет вызван перед методом validate(). Может быть использован для того что бы подготовить данные для валидации или других ситуаций.

**afterValidate**

Метод который будет вызван сразу после методом validate()

**afterConstruct**

Метод который является некой заменой конструктора модели. Метод вызывается для каждого экземпляра при использовании new.

```php
// создаем экземпляр модели
$a = new MyModel();
// тут же автоматически вызывается метод afterConstruct()
```

**afterFind**

Метод который будет вызван для каждого экземпляра модели, который был создан при использовании метода Find. Например:

```php
$a = MyModel::model()->findByPk(3);
```

**tableName**

Метод возвращает название таблицы с которой работает модель.
```php
public function tableName()
{
    return 'Users';
}
```
**safeAttributes**

Метод возвращает массив с безопасными атрибутами. Т.е. теми которые могут быть перезаписаны при массовом присваивании. Если вы хотите использовать safeAttributes() вам необходимо переопределить её в моделе.

Более подробно про safeAttributes() читайте:

1. Урок 6 : Регистрация и авторизация. Часть 1. Пункт «Работа с моделью. Правила валидации.»

2. «Создание модели»

**attributeLabels**

Метод возвращает массив соответствий. В нем необходимо перечислить какому атрибуту какое реальное название соответствует.

```php
public function attributeLabels()
{
    return array(
        'login'        => 'это у нас логин',
        'passwd'     => 'это у нас пароль',
}
```

Теперь в форме где мы используем Chtml::activeLabel вместо login/passwd будет отображаться текст указанный как соответствие.

**save**

Метод сохраняет текущие поля экземпляра AR. При этом самостоятельно анализирует факт наличия заполненного первичного ключа (в зависимости от этого делает update или insert)

Если первичный ключ явно не указан, значит save() выполнит insert:

```php
$a = MyModel();
$a->login = «test»;
$a->save();
```

А вот так будет update:

```php
$a = MyModel::model()->findByPk(3);
$a->login = «test»;
$a->save();
```

Теперь для записи у которой id равняется трём - логин будет изменен на «test».

Используя атрибут isNewRecord вы всегда можете проверить была вставлена новая запись, или обновлена существующая.

**rules**

В моделе вы можете указать правила (rules) для атрибутов. Это позволит контролировать какие данные приложение пытается сохранить в базу данных.

Проверка соответствия атрибутов вашим правилам будет происходить при вызове метода validate(). Поэтому перед тем как сохранить данные в базу — сначала делайте валидацию.

```php
if ($my_model->validate()) {
  $my_model->save();
}
```

Для того что бы использовать правила в вашем моделе — вам необходимо переопределить метод rules(). Для того что бы более подробно вникнуть в данный материал — вам помогут следующие статьи:

1. Созданием модели
2. Валидация формы средствами Yii

```php
public function rules()
{
return array(
    // поля login,passwd не должны быть пустыми
    array('login,passwd', 'required'),
    // поле login должно быть больше трёх и меньше 128-и символов
    array('login', 'length', 'max'=>128, 'min' => 3),
);
}
```